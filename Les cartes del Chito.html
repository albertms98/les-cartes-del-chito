<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Les cartes del Chito</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e0ffe0; /* Light green background */
        }
        /* Active tab styling changed to green tones */
        .tab-button.active {
            border-color: #22c55e; /* Tailwind green-600 */
            color: #22c55e; /* Tailwind green-600 */
            background-color: #f0fff0; /* Very light green */
        }
        .card-container {
            position: relative;
            display: inline-block;
            margin: 0.5rem;
        }
        .card-count {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 9999px; /* Full rounded */
            padding: 0.25rem 0.6rem;
            font-size: 0.875rem; /* text-sm */
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 1.75rem; /* w-7 */
            min-height: 1.75rem; /* h-7 */
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 5; /* Ensure it's above the image */
        }
        .autocomplete-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }
        .autocomplete-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .autocomplete-item:hover {
            background-color: #f3f4f6;
        }
        .card-thumbnail {
            width: 96px; /* A bit smaller for lists */
            height: auto;
            border-radius: 0.375rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border: 1px solid #e5e7eb;
        }
        .commander-card-display {
            width: 128px; /* Slightly larger for commander */
            height: auto;
            border-radius: 0.5rem;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            border: 2px solid #22c55e; /* Highlight commander with green */
        }
        .deck-item {
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
        }
        .deck-item:hover {
            background-color: #d0f0d0; /* Slightly darker light green on hover */
            transform: translateY(-2px);
        }
        .deck-item.selected {
            border-color: #22c55e; /* Tailwind green-600 */
            background-color: #e0ffe0; /* Light green */
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        /* Custom Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            max-width: 400px;
            width: 90%;
            text-align: center;
        }

        /* Color Filter Icons */
        .color-filter-icon {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            font-size: 1.5rem; /* Adjust font size for emojis */
        }
        .color-filter-icon:hover {
            border-color: #a0a0a0;
            transform: translateY(-1px);
        }
        .color-filter-icon.selected {
            border-color: #22c55e; /* Green highlight for selected */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transform: scale(1.05);
        }
        /* Specific background colors for icons */
        .color-filter-icon[data-color="W"] { background-color: #f8f6d8; } /* White */
        .color-filter-icon[data-color="U"] { background-color: #c1d8ed; } /* Blue */
        .color-filter-icon[data-color="B"] { background-color: #b3a2c7; } /* Black */
        .color-filter-icon[data-color="R"] { background-color: #e49987; } /* Red */
        .color-filter-icon[data-color="G"] { background-color: #a9c79f; } /* Green */
        .color-filter-icon[data-color="C"] { background-color: #d8d8d8; } /* Colorless */

        /* Mana Curve Bar Chart */
        .mana-bar {
            width: 30px; /* Fixed width for each bar */
            background-color: #4CAF50; /* Green color for bars */
            margin: 0 2px;
            border-radius: 3px 3px 0 0;
            transition: height 0.3s ease-out;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            position: relative;
        }
        .mana-bar-label {
            position: absolute;
            top: -1.2em;
            font-size: 0.75rem;
            color: #333;
            font-weight: bold;
        }
        .mana-bar-cmc {
            position: absolute;
            bottom: -1.5em;
            font-size: 0.75rem;
            color: #555;
        }
        /* Style for quick add/remove buttons on collection cards */
        .collection-card-actions {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: space-around;
            padding: 0.25rem;
            border-radius: 0 0 0.375rem 0.375rem;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        .card-container:hover .collection-card-actions {
            opacity: 1;
        }
        .collection-card-actions button {
            background-color: #4CAF50; /* Green */
            color: white;
            border: none;
            padding: 0.2rem 0.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.8rem;
            line-height: 1;
            transition: background-color 0.2s;
        }
        .collection-card-actions button.delete-btn {
            background-color: #ef4444; /* Red */
        }
        .collection-card-actions button:hover {
            background-color: #388E3C; /* Darker green */
        }
        .collection-card-actions button.delete-btn:hover {
            background-color: #dc2626; /* Darker red */
        }

        /* Styles for the new collection card display */
        .collection-card-item {
            display: flex;
            align-items: center;
            background-color: white;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            width: 100%; /* Take full width of the container */
            gap: 0.75rem;
        }
        .collection-card-item img {
            width: 64px; /* Smaller thumbnail */
            height: auto;
            border-radius: 0.25rem;
            border: 1px solid #d1d5db;
        }
        .collection-card-info {
            flex-grow: 1;
        }
        .collection-card-info .card-name {
            font-weight: 600;
            color: #374151;
            cursor: pointer; /* Indicate hoverable */
            text-decoration: none; /* Remove default underline */
        }
        .collection-card-info .card-name:hover {
            text-decoration: underline; /* Add underline on hover */
        }
        .collection-card-info .card-price {
            font-size: 0.875rem;
            color: #4b5563;
        }
        .collection-card-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .collection-card-controls button {
            padding: 0.3rem 0.6rem;
            font-size: 0.875rem;
            font-weight: bold;
            border-radius: 0.375rem;
            transition: background-color 0.2s;
        }
        .collection-card-controls .btn-minus {
            background-color: #f87171; /* Red-400 */
            color: white;
        }
        .collection-card-controls .btn-minus:hover {
            background-color: #ef4444; /* Red-500 */
        }
        .collection-card-controls .btn-plus {
            background-color: #34d399; /* Green-400 */
            color: white;
        }
        .collection-card-controls .btn-plus:hover {
            background-color: #10b981; /* Green-500 */
        }
        .collection-card-controls .btn-delete {
            background-color: #9ca3af; /* Gray-400 */
            color: white;
        }
        .collection-card-controls .btn-delete:hover {
            background-color: #6b7280; /* Gray-500 */
        }
        .collection-card-count {
            font-weight: bold;
            color: #1f2937;
            min-width: 1.5rem;
            text-align: center;
        }

        /* Hover Card Display */
        #hover-card-display {
            position: fixed;
            background-color: white;
            padding: 0.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            border: 1px solid #d1d5db;
            z-index: 1000; /* Ensure it's on top */
            pointer-events: none; /* Allow mouse events to pass through */
            transition: opacity 0.1s ease-in-out;
            opacity: 0; /* Start hidden */
        }
        #hover-card-display.visible {
            opacity: 1; /* Make visible */
        }
        #hover-card-image {
            width: 200px; /* Adjust size as needed */
            height: auto;
            border-radius: 0.375rem;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4 sm:p-6 bg-green-100">

    <!-- Main Container -->
    <div class="w-full max-w-4xl bg-white rounded-lg shadow-xl p-6 sm:p-8">
        <h1 class="text-3xl sm:text-4xl font-bold text-center text-gray-800 mb-6">Les cartes del Chito</h1>

        <!-- Tab Navigation -->
        <div class="flex border-b border-gray-200 mb-6">
            <button id="tab1-btn" class="tab-button flex-1 py-3 px-4 text-center text-lg font-medium text-gray-600 rounded-t-lg transition-colors duration-200 active">
                Afegir Cartes
            </button>
            <button id="tab2-btn" class="tab-button flex-1 py-3 px-4 text-center text-lg font-medium text-gray-600 rounded-t-lg transition-colors duration-200">
                Crear Decks (Commander)
            </button>
            <button id="tab3-btn" class="tab-button flex-1 py-3 px-4 text-center text-lg font-medium text-gray-600 rounded-t-lg transition-colors duration-200">
                Cartes Disponibles
            </button>
            <button id="tab4-btn" class="tab-button flex-1 py-3 px-4 text-center text-lg font-medium text-gray-600 rounded-t-lg transition-colors duration-200">
                Llista de Desitjos
            </button>
        </div>

        <!-- Tab Content 1: Add Cards -->
        <div id="tab1-content" class="tab-content">
            <div class="mb-6">
                <label for="card-search" class="block text-gray-700 text-sm font-bold mb-2">Cerca una carta de Magic:</label>
                <div class="relative">
                    <input type="text" id="card-search" placeholder="Introdueix el nom de la carta..."
                           class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-200">
                    <div id="autocomplete-results" class="absolute w-full mt-1 bg-white rounded-lg shadow-lg autocomplete-list hidden">
                        <!-- Autocomplete results will be injected here -->
                    </div>
                </div>
            </div>

            <!-- Selected Card Display -->
            <div id="selected-card-display" class="mb-6 p-4 bg-gray-50 rounded-lg flex flex-col sm:flex-row items-center justify-center gap-4 border border-gray-200 hidden">
                <div class="relative">
                    <img id="card-image" src="" alt="Imatge de la carta" class="w-48 h-auto rounded-lg shadow-md border border-gray-300">
                    <div id="card-display-count" class="card-count hidden"></div>
                </div>
                <div class="text-center sm:text-left">
                    <h3 id="card-name-display" class="text-xl font-semibold text-gray-800 mb-2"></h3>
                    <button id="add-card-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
                        Afegir Carta
                    </button>
                </div>
            </div>

            <!-- Filters for Collection -->
            <div class="mt-8 p-4 bg-gray-50 rounded-lg border border-gray-200">
                <h2 class="text-xl font-bold text-gray-800 mb-4 text-center">Filtra la teva Col¬∑lecci√≥</h2>
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                    <!-- Name Filter -->
                    <div>
                        <label class="block text-gray-700 text-sm font-bold mb-2">Cerca per nom:</label>
                        <input type="text" id="collection-name-filter" placeholder="Nom de la carta..."
                               class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent">
                    </div>
                    <!-- Color Filter with Logos -->
                    <div>
                        <label class="block text-gray-700 text-sm font-bold mb-2">Color:</label>
                        <div id="color-filter-icons" class="flex flex-wrap gap-2">
                            <!-- White (Sun) -->
                            <div class="color-filter-icon" data-color="W" title="Blanc">‚òÄÔ∏è</div>
                            <!-- Blue (Water Drop) -->
                            <div class="color-filter-icon" data-color="U" title="Blau">üíß</div>
                            <!-- Black (Skull) -->
                            <div class="color-filter-icon" data-color="B" title="Negre">üíÄ</div>
                            <!-- Red (Mountain) -->
                            <div class="color-filter-icon" data-color="R" title="Vermell">‚õ∞Ô∏è</div>
                            <!-- Green (Tree) -->
                            <div class="color-filter-icon" data-color="G" title="Verd">üå≥</div>
                            <!-- Colorless (Diamond) -->
                            <div class="color-filter-icon" data-color="C" title="Incolor">üíé</div>
                        </div>
                    </div>

                    <!-- Mana Value Filter -->
                    <div>
                        <label class="block text-gray-700 text-sm font-bold mb-2">Valor de Man√† (CMC):</label>
                        <div class="flex gap-2">
                            <input type="number" id="min-cmc-filter" placeholder="M√≠n."
                                   class="shadow appearance-none border rounded-lg w-1/2 py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent">
                            <input type="number" id="max-cmc-filter" placeholder="M√†x."
                                   class="shadow appearance-none border rounded-lg w-1/2 py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent">
                        </div>
                    </div>

                    <!-- Card Type Filter -->
                    <div>
                        <label class="block text-gray-700 text-sm font-bold mb-2">Tipus de Carta:</label>
                        <select id="type-filter" multiple
                                class="shadow border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent">
                            <option value="Creature">Criature</option>
                            <option value="Instant">Instant</option>
                            <option value="Planeswalker">Planeswalker</option>
                            <option value="Enchantment">Enchantment</option>
                            <option value="Land">Land</option>
                            <option value="Artifact">Artefact</option>
                            <option value="Sorcery">Sorcery</option>
                            <option value="Legendary">Llegendari</option>
                        </select>
                    </div>

                    <!-- Creature Type Filter (Initially Hidden) -->
                    <div id="creature-type-filter-group" class="hidden">
                        <label class="block text-gray-700 text-sm font-bold mb-2">Tipus de Criatura:</label>
                        <select id="creature-type-filter" multiple
                                class="shadow border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent">
                            <!-- Options will be dynamically populated -->
                        </select>
                    </div>

                </div>
                <div class="mt-4 text-center">
                    <button id="apply-filters-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
                        Aplicar Filtres
                    </button>
                    <button id="clear-filters-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 ml-2">
                        Netejar Filtres
                    </button>
                </div>
            </div>


            <!-- Added Cards List -->
            <div class="mt-8">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">La teva Col¬∑lecci√≥</h2>
                <div id="added-cards-list" class="flex flex-col gap-2 p-4 bg-gray-50 rounded-lg border border-gray-200 min-h-[150px]">
                    <p id="no-cards-message" class="text-gray-500 italic text-center">Encara no has afegit cap carta.</p>
                    <!-- Added cards will be displayed here -->
                </div>
            </div>
        </div>

        <!-- Tab Content 2: Create Decks (Commander) -->
        <div id="tab2-content" class="tab-content hidden">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Crear i Gestionar Mazos Commander</h2>

            <!-- Deck Management Section -->
            <div class="mb-6 p-4 bg-gray-50 rounded-lg border border-gray-200">
                <h3 class="text-xl font-semibold text-gray-800 mb-3">Els meus Mazos</h3>
                <div class="flex flex-wrap gap-3 mb-4" id="deck-list-container">
                    <p id="no-decks-message" class="text-gray-500 italic">Encara no has creat cap mazo.</p>
                    <!-- Deck items will be rendered here -->
                </div>
                <div class="flex flex-col sm:flex-row gap-3">
                    <input type="text" id="new-deck-name-input" placeholder="Nom del nou mazo..."
                           class="shadow appearance-none border rounded-lg flex-1 py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-200">
                    <button id="create-new-deck-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
                        Crear Nou Mazo
                    </button>
                </div>
            </div>

            <!-- Current Deck Editing Area (conditionally hidden) -->
            <div id="current-deck-editing-area" class="hidden">
                <h3 class="text-xl font-semibold text-gray-800 mb-3 text-center">Editant Mazo: <span id="editing-deck-name" class="font-bold"></span></h3>

                <!-- Commander Selection -->
                <div class="mb-6 p-4 bg-gray-50 rounded-lg border border-gray-200">
                    <h4 class="text-lg font-semibold text-gray-800 mb-3">Comandant</h4>
                    <div class="relative mb-4">
                        <input type="text" id="commander-search" placeholder="Cerca el teu comandant..."
                               class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-200">
                        <div id="commander-autocomplete-results" class="absolute w-full mt-1 bg-white rounded-lg shadow-lg autocomplete-list hidden">
                            <!-- Autocomplete results for commander will be injected here -->
                        </div>
                    </div>
                    <div id="current-commander-display" class="flex flex-col sm:flex-row items-center justify-center gap-4 p-3 bg-white rounded-lg shadow-sm border border-gray-200 hidden">
                        <img id="commander-image" src="" alt="Imatge del Comandant" class="commander-card-display">
                        <div class="text-center sm:text-left">
                            <h5 id="commander-name-display" class="text-base font-medium text-gray-800"></h5>
                            <button id="remove-commander-btn" class="mt-2 bg-red-500 hover:bg-red-600 text-white text-sm font-bold py-1 px-3 rounded-lg shadow-md transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2">
                                Eliminar Comandant
                            </button>
                        </div>
                    </div>
                    <p id="no-commander-message" class="text-gray-500 italic text-center py-2">Selecciona un comandant de la teva col¬∑lecci√≥.</p>
                </div>

                <!-- Deck Cards and Collection -->
                <div class="flex flex-col lg:flex-row gap-6">
                    <!-- Your Collection (for deck building) -->
                    <div class="flex-1 p-4 bg-gray-50 rounded-lg border border-gray-200">
                        <h4 class="text-lg font-semibold text-gray-800 mb-3 text-center">La teva Col¬∑lecci√≥</h4>
                        <input type="text" id="deck-collection-search" placeholder="Cerca cartes a la teva col¬∑lecci√≥..."
                               class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent mb-3">
                        <div id="deck-collection-list" class="flex flex-wrap justify-center gap-3 max-h-96 overflow-y-auto p-2">
                            <p id="no-cards-in-collection-message" class="text-gray-500 italic">No hi ha cartes a la teva col¬∑lecci√≥ per afegir al mazo.</p>
                            <!-- Cards from addedCards will be displayed here for selection -->
                        </div>
                    </div>

                    <!-- Current Deck List -->
                    <div class="flex-1 p-4 bg-gray-50 rounded-lg border border-gray-200">
                        <h4 class="text-lg font-semibold text-gray-800 mb-3 text-center">Cartes del Mazo (<span id="deck-card-count">0</span>/100)</h4>
                        <div id="current-deck-list" class="flex flex-wrap justify-center gap-3 max-h-96 overflow-y-auto p-2">
                            <p id="no-deck-cards-message" class="text-gray-500 italic">Afegeix cartes al teu mazo.</p>
                            <!-- Cards added to the deck will be displayed here -->
                        </div>
                        <!-- Deck Statistics -->
                        <div class="mt-6 p-4 bg-white rounded-lg shadow-sm border border-gray-200">
                            <h4 class="text-lg font-semibold text-gray-800 mb-3 text-center">Estad√≠stiques del Mazo</h4>
                            <div id="deck-type-counts" class="mb-4">
                                <h5 class="text-md font-medium text-gray-700 mb-2">Cartes per Tipus:</h5>
                                <!-- Type counts will be rendered here -->
                            </div>
                            <div id="mana-curve-chart">
                                <h5 class="text-md font-medium text-gray-700 mb-2">Corba de Man√†:</h5>
                                <div class="flex items-end justify-center h-32 bg-gray-100 rounded-lg p-2" id="mana-curve-bars">
                                    <!-- Mana curve bars will be rendered here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tab Content 3: Available Cards -->
        <div id="tab3-content" class="tab-content hidden">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Cartes Disponibles</h2>
            <div class="p-4 bg-gray-50 rounded-lg border border-gray-200 min-h-[200px]">
                <p id="no-available-cards-message" class="text-gray-500 italic text-center">No hi ha cartes disponibles que no estiguin als teus mazos.</p>
                <div id="available-cards-list" class="flex flex-wrap justify-center gap-4">
                    <!-- Available cards will be displayed here -->
                </div>
            </div>
        </div>

        <!-- Tab Content 4: Wishlist -->
        <div id="tab4-content" class="tab-content hidden">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Llista de Desitjos</h2>

            <div class="mb-6">
                <label for="wishlist-card-search" class="block text-gray-700 text-sm font-bold mb-2">Cerca una carta per afegir a la llista de desitjos:</label>
                <div class="relative">
                    <input type="text" id="wishlist-card-search" placeholder="Introdueix el nom de la carta..."
                           class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-200">
                    <div id="wishlist-autocomplete-results" class="absolute w-full mt-1 bg-white rounded-lg shadow-lg autocomplete-list hidden">
                        <!-- Autocomplete results for wishlist will be injected here -->
                    </div>
                </div>
            </div>

            <!-- Selected Card Display for Wishlist -->
            <div id="wishlist-selected-card-display" class="mb-6 p-4 bg-gray-50 rounded-lg flex flex-col sm:flex-row items-center justify-center gap-4 border border-gray-200 hidden">
                <div class="relative">
                    <img id="wishlist-card-image" src="" alt="Imatge de la carta" class="w-48 h-auto rounded-lg shadow-md border border-gray-300">
                    <!-- No count for wishlist as it's typically 1 copy -->
                </div>
                <div class="text-center sm:text-left">
                    <h3 id="wishlist-card-name-display" class="text-xl font-semibold text-gray-800 mb-2"></h3>
                    <button id="add-to-wishlist-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
                        Afegir a la Llista de Desitjos
                    </button>
                </div>
            </div>

            <!-- Wishlist Cards List -->
            <div class="mt-8">
                <h3 class="text-2xl font-bold text-gray-800 mb-4 text-center">La teva Llista de Desitjos</h3>
                <div id="wishlist-cards-list" class="flex flex-wrap justify-center gap-4 p-4 bg-gray-50 rounded-lg border border-gray-200 min-h-[150px]">
                    <p id="no-wishlist-cards-message" class="text-gray-500 italic">La teva llista de desitjos est√† buida.</p>
                    <!-- Wishlist cards will be displayed here -->
                </div>
            </div>
        </div>
    </div>

    <!-- User ID Display -->
    <div class="mt-4 text-center text-gray-600 text-sm">
        El teu ID d'usuari: <span id="user-id-display" class="font-mono text-gray-800">Carregant...</span>
    </div>

    <!-- Custom Confirmation Modal -->
    <div id="confirmation-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <p id="modal-message" class="text-lg text-gray-800 mb-6"></p>
            <div class="flex justify-center gap-4">
                <button id="modal-confirm-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2">
                    Confirmar
                </button>
                <button id="modal-cancel-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">
                    Cancel¬∑lar
                </button>
            </div>
        </div>
    </div>

    <!-- Hover Card Display (for showing card image on hover) -->
    <div id="hover-card-display" class="fixed hidden bg-white p-2 rounded-lg shadow-xl border border-gray-300 z-50 pointer-events-none">
        <img id="hover-card-image" src="" alt="Card Preview" class="w-48 h-auto rounded-lg">
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="modal-overlay">
        <div class="modal-content flex flex-col items-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-green-700 mb-4"></div>
            <p class="text-lg text-gray-800">Carregant dades...</p>
        </div>
    </div>

    <script type="module">
        // Import Firebase functions directly
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, addDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Global Variables ---
        let app;
        let db;
        let auth;
        let userId;
        let appId;
        let firebaseReady = false; // New flag to indicate Firebase is ready

        // IMPORTANT: Change these references for shared data
        let addedCardsRef;
        let commanderDecksRef;
        let wishlistCardsRef;

        // --- Global Variables and DOM Elements ---
        const cardSearchInput = document.getElementById('card-search');
        const autocompleteResultsDiv = document.getElementById('autocomplete-results');
        const selectedCardDisplay = document.getElementById('selected-card-display');
        const cardImage = document.getElementById('card-image');
        const cardNameDisplay = document.getElementById('card-name-display');
        const cardDisplayCount = document.getElementById('card-display-count');
        const addCardBtn = document.getElementById('add-card-btn');
        const addedCardsList = document.getElementById('added-cards-list');
        const noCardsMessage = document.getElementById('no-cards-message');

        // Tab 1 Filter elements
        const collectionNameFilterInput = document.getElementById('collection-name-filter'); 
        const colorFilterIconsContainer = document.getElementById('color-filter-icons');
        const minCmcFilterInput = document.getElementById('min-cmc-filter');
        const maxCmcFilterInput = document.getElementById('max-cmc-filter');
        const typeFilterSelect = document.getElementById('type-filter');
        const applyFiltersBtn = document.getElementById('apply-filters-btn');
        const clearFiltersBtn = document.getElementById('clear-filters-btn');

        // Creature Type Filter elements
        const creatureTypeFilterGroup = document.getElementById('creature-type-filter-group');
        const creatureTypeFilterSelect = document.getElementById('creature-type-filter');


        // Tab 2 elements
        const deckListContainer = document.getElementById('deck-list-container');
        const noDecksMessage = document.getElementById('no-decks-message');
        const newDeckNameInput = document.getElementById('new-deck-name-input');
        const createNewDeckBtn = document.getElementById('create-new-deck-btn'); 
        const currentDeckEditingArea = document.getElementById('current-deck-editing-area');
        const editingDeckNameSpan = document.getElementById('editing-deck-name');

        const commanderSearchInput = document.getElementById('commander-search');
        const commanderAutocompleteResultsDiv = document.getElementById('commander-autocomplete-results');
        const currentCommanderDisplay = document.getElementById('current-commander-display');
        const commanderImage = document.getElementById('commander-image');
        const commanderNameDisplay = document.getElementById('commander-name-display');
        const removeCommanderBtn = document.getElementById('remove-commander-btn');
        const noCommanderMessage = document.getElementById('no-commander-message');
        
        // Tab 2 Collection Search and List
        const deckCollectionSearchInput = document.getElementById('deck-collection-search');
        const deckCollectionList = document.getElementById('deck-collection-list');
        const noCardsInCollectionMessage = document.getElementById('no-cards-in-collection-message');
        
        // Tab 2 Deck List and Statistics
        const currentDeckList = document.getElementById('current-deck-list');
        const noDeckCardsMessage = document.getElementById('no-deck-cards-message');
        const deckCardCountSpan = document.getElementById('deck-card-count');
        const deckTypeCountsDiv = document.getElementById('deck-type-counts');
        const manaCurveBarsDiv = document.getElementById('mana-curve-bars');


        // Tab 3 elements
        const availableCardsList = document.getElementById('available-cards-list');
        const noAvailableCardsMessage = document.getElementById('no-available-cards-message');

        // Tab 4 elements (Wishlist)
        const wishlistCardSearchInput = document.getElementById('wishlist-card-search');
        const wishlistAutocompleteResultsDiv = document.getElementById('wishlist-autocomplete-results');
        const wishlistSelectedCardDisplay = document.getElementById('wishlist-selected-card-display');
        const wishlistCardImage = document.getElementById('wishlist-card-image');
        const wishlistCardNameDisplay = document.getElementById('wishlist-card-name-display');
        const addToWishlistBtn = document.getElementById('add-to-wishlist-btn');
        const wishlistCardsList = document.getElementById('wishlist-cards-list');
        const noWishlistCardsMessage = document.getElementById('no-wishlist-cards-message');

        // User ID Display
        const userIdDisplay = document.getElementById('user-id-display');


        // Custom Modal Elements
        const confirmationModal = document.getElementById('confirmation-modal');
        const modalMessage = document.getElementById('modal-message');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        // Hover Card Display Elements
        const hoverCardDisplay = document.getElementById('hover-card-display');
        const hoverCardImage = document.getElementById('hover-card-image');

        // Loading Overlay
        const loadingOverlay = document.getElementById('loading-overlay');


        let currentCard = null; // Stores the currently selected card object from Scryfall for Tab 1
        // Stores all cards added by the user: { card_id: { card_data, count } }
        let addedCards = {}; // In-memory collection of all cards the user owns

        // Stores all Commander decks: { deck_id: { id, name, commander, cards: { card_id: { card_data, count } }, totalCount } }
        let allCommanderDecks = {};
        let selectedDeckId = null; // ID of the currently active deck for editing

        // Stores cards in the wishlist: { card_id: { card_data } } (assuming 1 copy per wishlist entry)
        let wishlistCards = {};
        let currentWishlistCard = null; // Stores the currently selected card for wishlist add

        // --- Filter State for Tab 1 ---
        let currentFilters = {
            name: '', // Name filter for collection
            colors: [], // Array of selected color codes (W, U, B, R, G, C)
            minCmc: null,
            maxCmc: null,
            types: [], // Array of selected type strings (e.g., "Creature", "Instant")
            creatureTypes: [] // Array of selected creature type strings
        };

        // --- Utility Functions ---

        // Function to debounce API calls
        let debounceTimeout;
        const debounce = (func, delay) => {
            return (...args) => {
                clearTimeout(debounceTimeout);
                debounceTimeout = setTimeout(() => func.apply(this, args), delay);
            };
        };

        // Custom alert function (replaces window.alert)
        const showAlert = (message) => {
            console.log("ALERTA: " + message);
            const messageDiv = document.createElement('div');
            messageDiv.textContent = message;
            messageDiv.className = 'fixed top-4 right-4 bg-red-500 text-white p-3 rounded-lg shadow-lg z-50';
            document.body.appendChild(messageDiv);
            setTimeout(() => messageDiv.remove(), 3000); // Remove after 3 seconds
        };

        // Custom confirmation modal functions
        let onConfirmCallback = null;

        const showConfirmModal = (message, callback) => {
            modalMessage.textContent = message;
            onConfirmCallback = callback;
            confirmationModal.classList.remove('hidden');
        };

        const hideConfirmModal = () => {
            confirmationModal.classList.add('hidden');
            onConfirmCallback = null;
        };

        modalConfirmBtn.addEventListener('click', () => {
            if (onConfirmCallback) {
                onConfirmCallback(true);
            }
            hideConfirmModal();
        });

        modalCancelBtn.addEventListener('click', () => {
            if (onConfirmCallback) {
                onConfirmCallback(false);
            }
            hideConfirmModal();
        });

        // --- Hover Card Display Functions ---
        const showHoverCard = (event, cardId) => {
            const cardData = addedCards[cardId]?.card_data;
            if (cardData && cardData.image_uris && cardData.image_uris.normal) {
                hoverCardImage.src = cardData.image_uris.normal;
                hoverCardImage.alt = cardData.name;
                hoverCardDisplay.classList.add('visible'); // Use 'visible' class for opacity transition
                hoverCardDisplay.classList.remove('hidden');

                // Position the hover card near the mouse
                // Adjust positioning to avoid going off-screen
                const x = event.clientX + 20; // Offset from mouse
                const y = event.clientY + 20;

                // Simple boundary check (can be more sophisticated)
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const cardWidth = hoverCardImage.offsetWidth + 16; // Image width + padding
                const cardHeight = hoverCardImage.offsetHeight + 16; // Image height + padding

                if (x + cardWidth > viewportWidth - 10) { // 10px padding from right edge
                    hoverCardDisplay.style.left = `${event.clientX - cardWidth - 20}px`;
                } else {
                    hoverCardDisplay.style.left = `${x}px`;
                }

                if (y + cardHeight > viewportHeight - 10) { // 10px padding from bottom edge
                    hoverCardDisplay.style.top = `${event.clientY - cardHeight - 20}px`;
                } else {
                    hoverCardDisplay.style.top = `${y}px`;
                }
            }
        };

        const hideHoverCard = () => {
            hoverCardDisplay.classList.remove('visible');
            // Hide completely after transition if needed, or rely on opacity
            setTimeout(() => {
                if (!hoverCardDisplay.classList.contains('visible')) {
                    hoverCardDisplay.classList.add('hidden');
                }
            }, 150); // Match transition duration
        };


        // --- Tab 1: Add Cards Logic ---

        // Fetch autocomplete suggestions for Tab 1 search
        const fetchAutocomplete = async (query) => {
            if (query.length < 2) {
                autocompleteResultsDiv.classList.add('hidden');
                return;
            }
            try {
                const response = await fetch(`https://api.scryfall.com/cards/autocomplete?q=${encodeURIComponent(query)}`);
                const data = await response.json();
                displayAutocompleteResults(data.data);
            } catch (error) {
                console.error('Error fetching autocomplete data:', error);
                autocompleteResultsDiv.classList.add('hidden');
            }
        };

        // Display autocomplete results for Tab 1 search
        const displayAutocompleteResults = (results) => {
            autocompleteResultsDiv.innerHTML = '';
            if (results && results.length > 0) {
                results.forEach(cardName => {
                    const div = document.createElement('div');
                    div.classList.add('autocomplete-item');
                    div.textContent = cardName;
                    div.addEventListener('click', () => selectCardFromAutocomplete(cardName));
                    autocompleteResultsDiv.appendChild(div);
                });
                autocompleteResultsDiv.classList.remove('hidden');
            } else {
                autocompleteResultsDiv.classList.add('hidden');
            }
        };

        // Select a card from autocomplete and fetch its full data for Tab 1
        const selectCardFromAutocomplete = async (cardName) => {
            cardSearchInput.value = cardName;
            autocompleteResultsDiv.classList.add('hidden');
            try {
                const response = await fetch(`https://api.scryfall.com/cards/named?exact=${encodeURIComponent(cardName)}`);
                if (!response.ok) {
                    throw new Error(`Carta no trobada: ${cardName}`);
                }
                const cardData = await response.json();
                displaySelectedCard(cardData);
            } catch (error) {
                console.error('Error fetching card data:', error);
                selectedCardDisplay.classList.add('hidden');
                showAlert('No s\'ha pogut trobar la carta o hi ha hagut un error de xarxa. Si us plau, prova-ho de nou.');
            }
        };

        // Display the selected card details in Tab 1
        const displaySelectedCard = (cardData) => {
            currentCard = cardData;
            cardImage.src = cardData.image_uris?.normal || 'https://placehold.co/223x310/cccccc/333333?text=Imatge+no+disponible';
            cardImage.alt = cardData.name;
            cardNameDisplay.textContent = cardData.name;

            if (addedCards[cardData.id]) {
                cardDisplayCount.textContent = addedCards[cardData.id].count;
                cardDisplayCount.classList.remove('hidden');
            } else {
                cardDisplayCount.classList.add('hidden');
            }

            selectedCardDisplay.classList.remove('hidden');
        };

        // Add card to collection in Tab 1
        addCardBtn.addEventListener('click', async () => {
            if (!firebaseReady) {
                showAlert('L\'aplicaci√≥ encara s\'est√† carregant. Si us plau, espera un moment.');
                return;
            }
            if (!currentCard) {
                showAlert('Si us plau, selecciona una carta primer.');
                return;
            }

            try {
                const cardId = currentCard.id;
                const currentCount = addedCards[cardId] ? addedCards[cardId].count : 0;
                const newCount = currentCount + 1;

                await setDoc(doc(addedCardsRef, cardId), {
                    card_data: currentCard,
                    count: newCount
                });

                // UI updates will be handled by the onSnapshot listener
                cardDisplayCount.textContent = newCount;
                cardDisplayCount.classList.remove('hidden');
                cardSearchInput.value = '';
                selectedCardDisplay.classList.add('hidden');
                currentCard = null;

                // Check if this card exists in the wishlist and remove it
                if (wishlistCards[cardId]) {
                    await deleteDoc(doc(wishlistCardsRef, cardId));
                    showAlert(`"${currentCard.name}" s'ha eliminat de la llista de desitjos.`);
                }
            } catch (error) {
                console.error('Error adding card to collection:', error);
                showAlert('Error en afegir la carta a la col¬∑lecci√≥. Si us plau, prova-ho de nou.');
            }
        });

        // Event listener for search input in Tab 1
        cardSearchInput.addEventListener('input', debounce((e) => {
            fetchAutocomplete(e.target.value);
        }, 300));

        // Hide autocomplete results when clicking outside for Tab 1
        document.addEventListener('click', (e) => {
            if (!autocompleteResultsDiv.contains(e.target) && e.target !== cardSearchInput) {
                autocompleteResultsDiv.classList.add('hidden');
            }
            if (!commanderAutocompleteResultsDiv.contains(e.target) && e.target !== commanderSearchInput) {
                commanderAutocompleteResultsDiv.classList.add('hidden');
            }
            if (!wishlistAutocompleteResultsDiv.contains(e.target) && e.target !== wishlistCardSearchInput) {
                wishlistAutocompleteResultsDiv.classList.add('hidden');
            }
        });

        // --- Filters Logic for Tab 1 Collection ---

        // Event listener for collection name filter
        collectionNameFilterInput.addEventListener('input', debounce((e) => {
            currentFilters.name = e.target.value.toLowerCase();
            renderAddedCardsList();
        }, 300));

        // Event listener for color filter icons
        colorFilterIconsContainer.addEventListener('click', (e) => {
            const iconDiv = e.target.closest('.color-filter-icon');
            if (iconDiv) {
                const colorCode = iconDiv.dataset.color;
                
                // If colorless is selected, it's exclusive
                if (colorCode === 'C') {
                    if (currentFilters.colors.includes('C')) {
                        currentFilters.colors = []; // Deselect all if C was selected
                    } else {
                        currentFilters.colors = ['C']; // Select only C
                    }
                } else { // Handle W, U, B, R, G
                    // If C was previously selected, clear it
                    if (currentFilters.colors.includes('C')) {
                        currentFilters.colors = [];
                    }
                    const index = currentFilters.colors.indexOf(colorCode);
                    if (index > -1) {
                        currentFilters.colors.splice(index, 1); // Deselect
                    } else {
                        currentFilters.colors.push(colorCode); // Select
                    }
                }
                updateColorFilterIcons(); // Update UI
                renderAddedCardsList(); // Apply filter
            }
        });

        // Update the visual state of color filter icons
        const updateColorFilterIcons = () => {
            document.querySelectorAll('.color-filter-icon').forEach(icon => {
                const colorCode = icon.dataset.color;
                if (currentFilters.colors.includes(colorCode)) {
                    icon.classList.add('selected');
                } else {
                    icon.classList.remove('selected');
                }
            });
        };

        // Populate creature type filter dropdown
        const populateCreatureTypeFilter = () => {
            const creatureTypes = new Set();
            for (const cardId in addedCards) {
                const card = addedCards[cardId].card_data;
                if (card.type_line && card.type_line.includes('Creature')) {
                    const parts = card.type_line.split('‚Äî');
                    if (parts.length > 1) {
                        const subtypes = parts[1].trim().split(' ');
                        subtypes.forEach(type => {
                            if (type) creatureTypes.add(type.trim());
                        });
                    }
                }
            }

            creatureTypeFilterSelect.innerHTML = ''; // Clear existing options
            const sortedTypes = Array.from(creatureTypes).sort();
            sortedTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                creatureTypeFilterSelect.appendChild(option);
            });
        };

        // Event listener for main type filter to show/hide creature type filter
        typeFilterSelect.addEventListener('change', () => {
            currentFilters.types = Array.from(typeFilterSelect.selectedOptions).map(option => option.value);
            if (currentFilters.types.includes('Creature')) {
                creatureTypeFilterGroup.classList.remove('hidden');
                populateCreatureTypeFilter(); // Populate when shown
            } else {
                creatureTypeFilterGroup.classList.add('hidden');
                Array.from(creatureTypeFilterSelect.options).forEach(option => option.selected = false); // Clear selection
                currentFilters.creatureTypes = []; // Clear filter state
            }
            renderAddedCardsList(); // Re-render to apply type filter change
        });

        // Event listener for creature type filter
        creatureTypeFilterSelect.addEventListener('change', () => {
            currentFilters.creatureTypes = Array.from(creatureTypeFilterSelect.selectedOptions).map(option => option.value);
            renderAddedCardsList(); // Re-render to apply creature type filter
        });


        // Apply filters to the addedCards and render the list
        const applyFilters = () => {
            currentFilters.name = collectionNameFilterInput.value.toLowerCase(); // Get current name filter value
            currentFilters.minCmc = minCmcFilterInput.value ? parseFloat(minCmcFilterInput.value) : null;
            currentFilters.maxCmc = maxCmcFilterInput.value ? parseFloat(maxCmcFilterInput.value) : null;
            
            // Get selected types from the dropdown
            currentFilters.types = Array.from(typeFilterSelect.selectedOptions).map(option => option.value);
            currentFilters.creatureTypes = Array.from(creatureTypeFilterSelect.selectedOptions).map(option => option.value);


            renderAddedCardsList();
        };

        // Clear all filters and re-render
        const clearFilters = () => {
            currentFilters.name = ''; // Clear name filter
            collectionNameFilterInput.value = ''; // Clear input field

            currentFilters.colors = [];
            updateColorFilterIcons(); // Clear color icon selections

            minCmcFilterInput.value = '';
            maxCmcFilterInput.value = '';
            
            // Deselect all options in the type filter
            Array.from(typeFilterSelect.options).forEach(option => option.selected = false);
            currentFilters.types = [];

            // Hide and clear creature type filter
            creatureTypeFilterGroup.classList.add('hidden');
            Array.from(creatureTypeFilterSelect.options).forEach(option => option.selected = false);
            creatureTypeFilterSelect.innerHTML = ''; // Clear options
            currentFilters.creatureTypes = [];

            renderAddedCardsList();
        };

        // Event listeners for filters
        applyFiltersBtn.addEventListener('click', applyFilters);
        clearFiltersBtn.addEventListener('click', clearFilters);

        // Render the added cards list, applying current filters
        const renderAddedCardsList = () => {
            addedCardsList.innerHTML = ''; // Clear existing list
            let filteredCardsCount = 0;

            // Convert addedCards object to an array for sorting and filtering
            const cardsArray = Object.values(addedCards);

            // Apply filters
            const filteredAndSortedCards = cardsArray.filter(item => {
                const card = item.card_data;
                let passesFilters = true;

                // Name Filter
                if (currentFilters.name && !card.name.toLowerCase().includes(currentFilters.name)) {
                    passesFilters = false;
                }

                // Color Filter Logic
                if (passesFilters && currentFilters.colors.length > 0) {
                    if (currentFilters.colors.includes('C')) { 
                        if (currentFilters.colors.length > 1 || (card.colors && card.colors.length > 0)) {
                            passesFilters = false;
                        } else if (card.colors && card.colors.length !== 0) {
                            passesFilters = false;
                        }
                    } else { 
                        const cardColors = card.colors || [];
                        const allSelectedColorsPresent = currentFilters.colors.every(filterColor => cardColors.includes(filterColor));
                        if (!allSelectedColorsPresent) {
                            passesFilters = false;
                        }
                    }
                }

                // Mana Value (CMC) Filter
                if (passesFilters && currentFilters.minCmc !== null && card.cmc < currentFilters.minCmc) {
                    passesFilters = false;
                }
                if (passesFilters && currentFilters.maxCmc !== null && card.cmc > currentFilters.maxCmc) {
                    passesFilters = false;
                }

                // Type Filter
                if (passesFilters && currentFilters.types.length > 0) {
                    let matchesType = false;
                    for (const filterType of currentFilters.types) {
                        if (card.type_line && card.type_line.includes(filterType)) {
                            matchesType = true;
                            break;
                        }
                    }
                    if (!matchesType) {
                        passesFilters = false;
                    }
                }

                // Creature Type Filter
                if (passesFilters && currentFilters.creatureTypes.length > 0) {
                    if (!card.type_line || !card.type_line.includes('Creature')) { 
                        passesFilters = false;
                    } else {
                        const cardSubtypes = card.type_line.split('‚Äî')[1]?.trim().split(' ');
                        const allSelectedCreatureTypesPresent = currentFilters.creatureTypes.every(filterCreatureType => cardSubtypes.includes(filterCreatureType));
                        if (!allSelectedCreatureTypesPresent) {
                            passesFilters = false;
                        }
                    }
                }
                return passesFilters;
            }).sort((a, b) => a.card_data.name.localeCompare(b.card_data.name)); // Sort alphabetically by name


            filteredCardsCount = filteredAndSortedCards.length;

            if (filteredCardsCount === 0) {
                noCardsMessage.classList.remove('hidden');
            } else {
                noCardsMessage.classList.add('hidden');
                filteredAndSortedCards.forEach(item => {
                    const card = item.card_data;
                    const count = item.count;
                    const cardId = card.id;

                    // Get Card Kingdom price
                    const priceUSD = card.prices?.usd || card.prices?.usd_foil; // Prefer non-foil, then foil
                    const formattedPrice = priceUSD ? `${parseFloat(priceUSD).toFixed(2)} USD` : 'N/A';

                    const cardElement = document.createElement('div');
                    cardElement.classList.add('collection-card-item'); // Use new class for styling
                    cardElement.innerHTML = `
                        <img src="${card.image_uris?.small || 'https://placehold.co/64x90/cccccc/333333?text=No+Image'}"
                             alt="${card.name}">
                        <div class="collection-card-info">
                            <div class="card-name" data-card-id="${cardId}">${card.name}</div>
                            <div class="card-price">Preu: ${formattedPrice}</div>
                        </div>
                        <div class="collection-card-controls">
                            <button class="btn-minus" data-card-id="${cardId}">-</button>
                            <span class="collection-card-count">${count}</span>
                            <button class="btn-plus" data-card-id="${cardId}">+</button>
                            <button class="btn-delete" data-card-id="${cardId}">X</button>
                        </div>
                    `;
                    addedCardsList.appendChild(cardElement);

                    // Add event listeners for the new buttons
                    cardElement.querySelector('.btn-minus').addEventListener('click', (e) => {
                        handleRemoveOneCard(e.target.dataset.cardId);
                    });
                    cardElement.querySelector('.btn-plus').addEventListener('click', (e) => {
                        handleAddOneCard(e.target.dataset.cardId);
                    });
                    cardElement.querySelector('.btn-delete').addEventListener('click', (e) => {
                        handleDeleteCardFromCollection(e.target.dataset.cardId);
                    });

                    // Add hover listeners for the card name
                    cardElement.querySelector('.card-name').addEventListener('mouseover', (e) => showHoverCard(e, cardId));
                    cardElement.querySelector('.card-name').addEventListener('mouseout', hideHoverCard);
                });
            }
        };

        // Handle decreasing card count in collection
        const handleRemoveOneCard = async (cardId) => {
            if (!firebaseReady) {
                showAlert('L\'aplicaci√≥ encara s\'est√† carregant. Si us plau, espera un moment.');
                return;
            }
            if (addedCards[cardId]) {
                const newCount = addedCards[cardId].count - 1;
                try {
                    if (newCount <= 0) {
                        await deleteDoc(doc(addedCardsRef, cardId));
                    } else {
                        await updateDoc(doc(addedCardsRef, cardId), { count: newCount });
                    }
                    // UI updates handled by onSnapshot
                } catch (error) {
                    console.error('Error removing one card from collection:', error);
                    showAlert('Error en disminuir la quantitat de la carta.');
                }
            }
        };

        // Handle increasing card count in collection
        const handleAddOneCard = async (cardId) => {
            if (!firebaseReady) {
                showAlert('L\'aplicaci√≥ encara s\'est√† carregant. Si us plau, espera un moment.');
                return;
            }
            if (addedCards[cardId]) {
                const newCount = addedCards[cardId].count + 1;
                try {
                    await updateDoc(doc(addedCardsRef, cardId), { count: newCount });
                    // UI updates handled by onSnapshot
                } catch (error) {
                    console.error('Error adding one card to collection:', error);
                    showAlert('Error en augmentar la quantitat de la carta.');
                }
            }
        };

        // Handle deleting card from collection
        const handleDeleteCardFromCollection = (cardId) => {
            if (!firebaseReady) {
                showAlert('L\'aplicaci√≥ encara s\'est√† carregant. Si us plau, espera un moment.');
                return;
            }
            if (addedCards[cardId]) {
                const cardName = addedCards[cardId].card_data.name;
                showConfirmModal(`Est√†s segur que vols eliminar "${cardName}" de la teva col¬∑lecci√≥?`, async (confirmed) => {
                    if (confirmed) {
                        try {
                            await deleteDoc(doc(addedCardsRef, cardId));
                            showAlert(`"${cardName}" eliminada de la col¬∑lecci√≥.`);
                            // UI updates handled by onSnapshot
                        } catch (error) {
                            console.error('Error deleting card from collection:', error);
                            showAlert('Error en eliminar la carta de la col¬∑lecci√≥.');
                        }
                    }
                });
            }
        };


        // --- Tab 2: Commander Deck Building Logic (Multi-Deck Support) ---

        // Render the list of all created decks
        const renderDeckList = () => {
            deckListContainer.innerHTML = ''; // Clear existing list
            const deckIds = Object.keys(allCommanderDecks);

            if (deckIds.length === 0) {
                noDecksMessage.classList.remove('hidden');
            } else {
                noDecksMessage.classList.add('hidden');
                deckIds.forEach(deckId => {
                    const deck = allCommanderDecks[deckId];
                    const deckItem = document.createElement('div');
                    deckItem.classList.add('deck-item', 'flex', 'items-center', 'justify-between', 'p-3', 'bg-white', 'rounded-lg', 'shadow-sm', 'border', 'border-gray-200', 'w-full', 'sm:w-auto', 'min-w-[150px]');
                    if (selectedDeckId === deckId) {
                        deckItem.classList.add('selected');
                    }
                    deckItem.dataset.deckId = deckId;
                    deckItem.innerHTML = `
                        <span class="font-medium text-gray-800 truncate">${deck.name}</span>
                        <span class="text-sm text-gray-500 ml-2">(${deck.totalCount} cartes)</span>
                        <button class="delete-deck-btn ml-3 bg-red-400 hover:bg-red-500 text-white text-xs font-bold py-1 px-2 rounded-full transition-colors duration-200" data-deck-id="${deckId}">X</button>
                    `;
                    deckItem.addEventListener('click', (e) => {
                        // Prevent selecting deck when clicking delete button
                        if (!e.target.classList.contains('delete-deck-btn')) {
                            selectDeck(deckId);
                        }
                    });
                    deckListContainer.appendChild(deckItem);
                });

                // Add event listeners for delete buttons
                document.querySelectorAll('.delete-deck-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent deck selection when deleting
                        const deckIdToDelete = e.target.dataset.deckId;
                        deleteDeck(deckIdToDelete);
                    });
                });
            }
        };

        // Create a new Commander deck
        createNewDeckBtn.addEventListener('click', async () => {
            if (!firebaseReady) {
                showAlert('L\'aplicaci√≥ encara s\'est√† carregant. Si us plau, espera un moment.');
                return;
            }
            const deckName = newDeckNameInput.value.trim();
            if (!deckName) {
                showAlert('Si us plau, introdueix un nom per al nou mazo.');
                return;
            }

            try {
                const newDeck = {
                    name: deckName,
                    commander: null,
                    cards: {},
                    totalCount: 0
                };
                const docRef = await addDoc(commanderDecksRef, newDeck);
                newDeck.id = docRef.id; // Get the ID generated by Firestore
                // UI updates will be handled by the onSnapshot listener
                newDeckNameInput.value = ''; // Clear input
                selectDeck(newDeck.id); // Automatically select the new deck for editing
            } catch (error) {
                console.error('Error creating new deck:', error);
                showAlert('Error en crear el nou mazo. Si us plau, prova-ho de nou.');
            }
        });

        // Helper function to get the primary type of a card for sorting and statistics
        const getPrimaryCardType = (card) => {
            if (!card || !card.card_data || !card.card_data.type_line) return '';
            const typeLine = card.card_data.type_line;
            const mainTypes = ['Creature', 'Instant', 'Planeswalker', 'Enchantment', 'Land', 'Artifact', 'Sorcery'];
            for (const mt of mainTypes) {
                if (typeLine.includes(mt)) {
                    return mt;
                }
            }
            return ''; // Default if no known primary type
        };

        // Comparator for sorting deck cards
        const typeOrder = {
            'Creature': 1,
            'Instant': 2,
            'Planeswalker': 3,
            'Enchantment': 4,
            'Land': 5,
            'Artifact': 6,
            'Sorcery': 7,
            // 'Legendary' is a supertype, not a primary type for this sorting.
            // If a card is just "Legendary" without another primary type (e.g., a token), it would fall to a higher order.
            // For this specific sorting, we prioritize the main types.
        };

        const sortDeckCards = (cardA, cardB) => {
            const typeA = getPrimaryCardType(cardA);
            const typeB = getPrimaryCardType(cardB);

            const orderA = typeOrder[typeA] || 99; // Assign a high number for unknown types
            const orderB = typeOrder[typeB] || 99;

            if (orderA !== orderB) {
                return orderA - orderB;
            }

            // If types are the same, sort by CMC
            const cmcA = cardA.card_data.cmc || 0;
            const cmcB = cardB.card_data.cmc || 0;
            if (cmcA !== cmcB) {
                return cmcA - cmcB;
            }

            // Finally, sort by name if types and CMC are the same
            return cardA.card_data.name.localeCompare(cardB.card_data.name);
        };

        // Select a deck for editing
        const selectDeck = (deckId) => {
            selectedDeckId = deckId;
            const selectedDeck = allCommanderDecks[selectedDeckId];

            if (!selectedDeck) {
                showAlert('Error: Mazo no trobat.');
                selectedDeckId = null;
                currentDeckEditingArea.classList.add('hidden');
                return;
            }

            editingDeckNameSpan.textContent = selectedDeck.name;
            currentDeckEditingArea.classList.remove('hidden');

            // Update Commander display
            if (selectedDeck.commander) {
                commanderImage.src = selectedDeck.commander.image_uris?.normal || 'https://placehold.co/128x178/cccccc/333333?text=No+Image';
                commanderImage.alt = selectedDeck.commander.name;
                commanderNameDisplay.textContent = selectedDeck.commander.name;
                currentCommanderDisplay.classList.remove('hidden');
                noCommanderMessage.classList.add('hidden');
                commanderSearchInput.value = selectedDeck.commander.name;
            } else {
                currentCommanderDisplay.classList.add('hidden');
                noCommanderMessage.classList.remove('hidden');
                commanderSearchInput.value = '';
            }

            // Populate deck cards list
            renderCurrentDeckList(); // Call the dedicated render function
            populateDeckCollection(); // Refresh collection list for adding to this deck
            updateDeckCardCount(); // Update total count for the selected deck
            renderDeckList(); // Re-render deck list to show selection
            renderAvailableCards(); // Update available cards list after deck selection
            updateDeckStatistics(); // Update statistics for the selected deck
        };

        // Render the current deck's card list, sorted
        const renderCurrentDeckList = () => {
            currentDeckList.innerHTML = ''; // Clear existing list
            if (!selectedDeckId) return;

            const currentDeck = allCommanderDecks[selectedDeckId];
            const deckCardsArray = Object.values(currentDeck.cards);

            // Sort the cards
            deckCardsArray.sort(sortDeckCards);

            if (deckCardsArray.length === 0) {
                noDeckCardsMessage.classList.remove('hidden');
            } else {
                noDeckCardsMessage.classList.add('hidden');
                deckCardsArray.forEach(deckCard => {
                    const cardElement = document.createElement('div');
                    cardElement.classList.add('relative', 'flex', 'flex-col', 'items-center', 'p-2', 'bg-white', 'rounded-lg', 'shadow-sm', 'border', 'border-gray-200', 'hover:shadow-md', 'transition-shadow', 'duration-200');
                    cardElement.style.width = '110px';

                    cardElement.innerHTML = `
                        <img src="${deckCard.card_data.image_uris?.small || 'https://placehold.co/96x134/cccccc/333333?text=No+Image'}"
                             alt="${deckCard.card_data.name}" class="card-thumbnail mb-1">
                        <span class="text-xs font-semibold text-gray-700 text-center truncate w-full px-1">${deckCard.card_data.name}</span>
                        <span class="card-count">${deckCard.count}</span>
                        <button data-card-id="${deckCard.card_data.id}" class="remove-from-deck-btn mt-2 bg-red-500 hover:bg-red-600 text-white text-xs font-bold py-1 px-2 rounded-lg shadow-sm transition-colors duration-200">
                            Eliminar
                        </button>
                    `;
                    currentDeckList.appendChild(cardElement);

                    cardElement.querySelector('.remove-from-deck-btn').addEventListener('click', (e) => {
                        const id = e.target.dataset.cardId;
                        removeCardFromDeck(id);
                    });
                });
            }
        };


        // Delete a Commander deck
        const deleteDeck = (deckId) => {
            if (!firebaseReady) {
                showAlert('L\'aplicaci√≥ encara s\'est√† carregant. Si us plau, espera un moment.');
                return;
            }
            showConfirmModal(`Est√†s segur que vols eliminar el mazo "${allCommanderDecks[deckId].name}"?`, async (confirmed) => {
                if (confirmed) {
                    try {
                        await deleteDoc(doc(commanderDecksRef, deckId));
                        // UI updates handled by onSnapshot
                        if (selectedDeckId === deckId) {
                            selectedDeckId = null; // Deselect if the deleted deck was active
                            currentDeckEditingArea.classList.add('hidden');
                        }
                    } catch (error) {
                        console.error('Error deleting deck:', error);
                        showAlert('Error en eliminar el mazo. Si us plau, prova-ho de nou.');
                    }
                }
            });
        };

        // Populate the collection list for deck building with search and limit
        const populateDeckCollection = (searchTerm = '') => {
            deckCollectionList.innerHTML = ''; // Clear previous list
            const allCollectionCards = Object.values(addedCards);

            let filteredCards = allCollectionCards.filter(item =>
                item.card_data.name.toLowerCase().includes(searchTerm.toLowerCase())
            );

            // Simple sorting by name for now, could be improved with fuzzy matching
            filteredCards.sort((a, b) => a.card_data.name.localeCompare(b.card_data.name));

            // Limit to 6 cards for horizontal display
            const cardsToDisplay = filteredCards.slice(0, 6);

            if (cardsToDisplay.length === 0) {
                noCardsInCollectionMessage.classList.remove('hidden');
                deckCollectionList.classList.remove('flex-wrap', 'justify-center');
            } else {
                noCardsInCollectionMessage.classList.add('hidden');
                deckCollectionList.classList.add('flex-wrap', 'justify-center');
            }

            cardsToDisplay.forEach(item => {
                const card = item.card_data;
                const count = item.count;

                const cardElement = document.createElement('div');
                cardElement.classList.add('relative', 'flex', 'flex-col', 'items-center', 'p-2', 'bg-white', 'rounded-lg', 'shadow-sm', 'border', 'border-gray-200', 'hover:shadow-md', 'transition-shadow', 'duration-200');
                cardElement.style.width = '110px';

                cardElement.innerHTML = `
                    <img src="${card.image_uris?.small || 'https://placehold.co/96x134/cccccc/333333?text=No+Image'}"
                         alt="${card.name}" class="card-thumbnail mb-1">
                    <span class="text-xs font-semibold text-gray-700 text-center truncate w-full px-1">${card.name}</span>
                    <span class="card-count">${count}</span>
                    <button data-card-id="${card.id}" class="add-to-deck-btn mt-2 bg-green-500 hover:bg-green-600 text-white text-xs font-bold py-1 px-2 rounded-lg shadow-sm transition-colors duration-200">
                        Afegir
                    </button>
                `;
                deckCollectionList.appendChild(cardElement);
            });

            document.querySelectorAll('#deck-collection-list .add-to-deck-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const cardId = e.target.dataset.cardId;
                    addCardToDeck(cardId);
                });
            });
        };

        // Event listener for deck collection search input
        deckCollectionSearchInput.addEventListener('input', debounce((e) => {
            populateDeckCollection(e.target.value);
        }, 300));


        // Fetch autocomplete suggestions for Commander search (only from addedCards)
        const fetchCommanderAutocomplete = (query) => {
            commanderAutocompleteResultsDiv.innerHTML = '';
            if (query.length < 2) {
                commanderAutocompleteResultsDiv.classList.add('hidden');
                return;
            }

            const matchingCards = Object.values(addedCards).filter(item =>
                item.card_data.name.toLowerCase().includes(query.toLowerCase())
            );

            if (matchingCards.length > 0) {
                matchingCards.forEach(item => {
                    const div = document.createElement('div');
                    div.classList.add('autocomplete-item');
                    div.textContent = item.card_data.name;
                    div.addEventListener('click', () => selectCommander(item.card_data));
                    commanderAutocompleteResultsDiv.appendChild(div);
                });
                commanderAutocompleteResultsDiv.classList.remove('hidden');
            } else {
                commanderAutocompleteResultsDiv.classList.add('hidden');
            }
        };

        // Select a Commander for the currently selected deck
        const selectCommander = async (cardData) => {
            if (!firebaseReady) {
                showAlert('L\'aplicaci√≥ encara s\'est√† carregant. Si us plau, espera un moment.');
                return;
            }
            if (!selectedDeckId) {
                showAlert('Si us plau, selecciona o crea un mazo primer.');
                return;
            }
            if (!addedCards[cardData.id]) {
                showAlert('Aquesta carta no √©s a la teva col¬∑lecci√≥. Si us plau, afegeix-la primer a la pestanya "Afegir Cartes".');
                commanderSearchInput.value = '';
                commanderAutocompleteResultsDiv.classList.add('hidden');
                return;
            }

            try {
                await updateDoc(doc(commanderDecksRef, selectedDeckId), {
                    commander: cardData
                });
                // UI updates handled by onSnapshot
                commanderSearchInput.value = cardData.name;
                commanderAutocompleteResultsDiv.classList.add('hidden');
            } catch (error) {
                console.error('Error setting commander:', error);
                showAlert('Error en seleccionar el comandant. Si us plau, prova-ho de nou.');
            }
        };

        // Remove Commander from the currently selected deck
        removeCommanderBtn.addEventListener('click', async () => {
            if (!firebaseReady) {
                showAlert('L\'aplicaci√≥ encara s\'est√† carregant. Si us plau, espera un moment.');
                return;
            }
            if (!selectedDeckId) return;
            try {
                await updateDoc(doc(commanderDecksRef, selectedDeckId), {
                    commander: null
                });
                // UI updates handled by onSnapshot
                commanderSearchInput.value = '';
            } catch (error) {
                console.error('Error removing commander:', error);
                showAlert('Error en eliminar el comandant. Si us plau, prova-ho de nou.');
            }
        });

        // Add card to the current deck
        const addCardToDeck = async (cardId) => {
            if (!firebaseReady) {
                showAlert('L\'aplicaci√≥ encara s\'est√† carregant. Si us plau, espera un moment.');
                return;
            }
            if (!selectedDeckId) {
                showAlert('Si us plau, selecciona o crea un mazo primer.');
                return;
            }

            const currentDeck = allCommanderDecks[selectedDeckId];
            const cardToAdd = addedCards[cardId];

            if (!cardToAdd) {
                showAlert('Error: La carta no es troba a la teva col¬∑lecci√≥.');
                return;
            }

            // Calculate total used count for this card across ALL decks
            const totalUsedInAllDecks = calculateUsedCards()[cardId] || 0;
            if (totalUsedInAllDecks >= cardToAdd.count) {
                showAlert(`Ja has afegit totes les c√≤pies de "${cardToAdd.card_data.name}" que tens a la teva col¬∑lecci√≥.`);
                return;
            }

            const newCardsState = { ...currentDeck.cards };
            if (newCardsState[cardId]) {
                newCardsState[cardId].count++;
            } else {
                newCardsState[cardId] = {
                    card_data: cardToAdd.card_data,
                    count: 1
                };
            }

            try {
                await updateDoc(doc(commanderDecksRef, selectedDeckId), {
                    cards: newCardsState
                });
                // UI updates handled by onSnapshot
            } catch (error) {
                console.error('Error adding card to deck:', error);
                showAlert('Error en afegir la carta al mazo. Si us plau, prova-ho de nou.');
            }
        };

        // Remove card from the current deck
        const removeCardFromDeck = async (cardId) => {
            if (!firebaseReady) {
                showAlert('L\'aplicaci√≥ encara s\'est√† carregant. Si us plau, espera un moment.');
                return;
            }
            if (!selectedDeckId) return;
            const currentDeck = allCommanderDecks[selectedDeckId];
            const newCardsState = { ...currentDeck.cards };

            if (newCardsState[cardId]) {
                newCardsState[cardId].count--;
                if (newCardsState[cardId].count <= 0) {
                    delete newCardsState[cardId];
                }
            }

            try {
                await updateDoc(doc(commanderDecksRef, selectedDeckId), {
                    cards: newCardsState
                });
                // UI updates handled by onSnapshot
            } catch (error) {
                console.error('Error removing card from deck:', error);
                showAlert('Error en eliminar la carta del mazo. Si us plau, prova-ho de nou.');
            }
        };

        // Update the total card count in the currently selected deck
        const updateDeckCardCount = () => {
            if (!selectedDeckId) {
                deckCardCountSpan.textContent = '0';
                return;
            }
            const currentDeck = allCommanderDecks[selectedDeckId];
            let total = 0;
            for (const cardId in currentDeck.cards) {
                total += currentDeck.cards[cardId].count;
            }
            if (currentDeck.commander) {
                total += 1; // Commander counts as one card
            }
            currentDeck.totalCount = total; // Update the in-memory object
            deckCardCountSpan.textContent = total;
        };

        // Event listener for Commander search input
        commanderSearchInput.addEventListener('input', debounce((e) => {
            fetchCommanderAutocomplete(e.target.value);
        }, 300));

        // --- Deck Statistics Logic ---
        const updateDeckStatistics = () => {
            if (!selectedDeckId) {
                deckTypeCountsDiv.innerHTML = '<h5 class="text-md font-medium text-gray-700 mb-2">Cartes per Tipus:</h5><p class="text-gray-500 italic">Selecciona un mazo per veure les estad√≠stiques.</p>';
                manaCurveBarsDiv.innerHTML = '';
                return;
            }

            const currentDeck = allCommanderDecks[selectedDeckId];
            const typeCounts = {};
            const manaCurve = {};
            let maxManaCount = 0;

            // Helper to get the primary type for counting, ignoring 'Legendary' supertype
            const getPrimaryTypeForCounting = (cardData) => {
                if (!cardData || !cardData.type_line) return 'Altres'; // Default to 'Altres' for unknown types

                const typeLine = cardData.type_line;
                // Order matters here for correct classification
                const mainTypes = ['Creature', 'Planeswalker', 'Enchantment', 'Artifact', 'Instant', 'Sorcery', 'Land'];
                
                for (const mt of mainTypes) {
                    if (typeLine.includes(mt)) {
                        return mt;
                    }
                }
                // Fallback for types not explicitly listed, taking the first word before '‚Äî'
                const parts = typeLine.split('‚Äî')[0].trim().split(' ');
                return parts[0] || 'Altres';
            };


            // Include commander in statistics
            if (currentDeck.commander) {
                const primaryType = getPrimaryTypeForCounting(currentDeck.commander);
                typeCounts[primaryType] = (typeCounts[primaryType] || 0) + 1;
                const cmc = Math.floor(currentDeck.commander.cmc);
                manaCurve[cmc] = (manaCurve[cmc] || 0) + 1;
                if (manaCurve[cmc] > maxManaCount) maxManaCount = manaCurve[cmc];
            }

            for (const cardId in currentDeck.cards) {
                const card = currentDeck.cards[cardId].card_data;
                const count = currentDeck.cards[cardId].count;

                // Type counts
                const primaryType = getPrimaryTypeForCounting(card);
                typeCounts[primaryType] = (typeCounts[primaryType] || 0) + count;

                // Mana curve
                const cmc = Math.floor(card.cmc); // Round down CMC for buckets
                manaCurve[cmc] = (manaCurve[cmc] || 0) + count;
                if (manaCurve[cmc] > maxManaCount) maxManaCount = manaCurve[cmc];
            }

            // Render Type Counts
            deckTypeCountsDiv.innerHTML = '<h5 class="text-md font-medium text-gray-700 mb-2">Cartes per Tipus:</h5>';
            // Define a custom order for displaying types
            const displayOrder = ['Creature', 'Planeswalker', 'Enchantment', 'Artifact', 'Instant', 'Sorcery', 'Land', 'Altres'];
            
            let displayedTypes = [];
            displayOrder.forEach(type => {
                if (typeCounts[type]) {
                    displayedTypes.push({ name: type, count: typeCounts[type] });
                }
            });

            // Add any other types not in the predefined order
            Object.keys(typeCounts).forEach(type => {
                if (!displayOrder.includes(type)) {
                    displayedTypes.push({ name: type, count: typeCounts[type] });
                }
            });

            if (displayedTypes.length === 0) {
                deckTypeCountsDiv.innerHTML += '<p class="text-gray-500 italic text-sm">No hi ha cartes al mazo.</p>';
            } else {
                displayedTypes.forEach(typeInfo => {
                    deckTypeCountsDiv.innerHTML += `<p class="text-sm text-gray-700">${typeInfo.name}: <strong>${typeInfo.count}</strong></p>`;
                });
            }

            // Render Mana Curve
            manaCurveBarsDiv.innerHTML = ''; // Clear previous bars
            const maxBarHeight = 100; // Max height in pixels for the tallest bar

            // Create bars for CMC 0 to 7+
            for (let i = 0; i <= 7; i++) {
                let cmcCount = manaCurve[i] || 0;
                let cmcLabel = i.toString();
                if (i === 7) {
                    // Sum all CMCs >= 7 for the 7+ bucket
                    cmcCount = 0;
                    for (const key in manaCurve) {
                        if (parseInt(key) >= 7) {
                            cmcCount += manaCurve[key];
                        }
                    }
                    cmcLabel = '7+';
                } else if (i > 7) {
                    // Skip if already handled by 7+
                    continue;
                }

                const barHeight = maxManaCount > 0 ? (cmcCount / maxManaCount) * maxBarHeight : 0;
                const bar = document.createElement('div');
                bar.classList.add('mana-bar');
                bar.style.height = `${barHeight}px`;
                bar.innerHTML = `
                    <span class="mana-bar-label">${cmcCount}</span>
                    <span class="mana-bar-cmc">${cmcLabel}</span>
                `;
                manaCurveBarsDiv.appendChild(bar);
            }
        };


        // --- Tab 3: Available Cards Logic ---

        // Helper function to calculate total used cards across all decks
        const calculateUsedCards = () => {
            const usedCounts = {};
            for (const deckId in allCommanderDecks) {
                const deck = allCommanderDecks[deckId];
                // Count commander if exists
                if (deck.commander) {
                    usedCounts[deck.commander.id] = (usedCounts[deck.commander.id] || 0) + 1;
                }
                // Count cards in deck
                for (const cardId in deck.cards) {
                    usedCounts[cardId] = (usedCounts[cardId] || 0) + deck.cards[cardId].count;
                }
            }
            return usedCounts;
        };

        // Render the list of available cards
        const renderAvailableCards = () => {
            availableCardsList.innerHTML = ''; // Clear previous list
            const usedCounts = calculateUsedCards();
            let hasAvailableCards = false;

            for (const cardId in addedCards) {
                const card = addedCards[cardId].card_data;
                const totalOwned = addedCards[cardId].count;
                const totalUsed = usedCounts[cardId] || 0;
                const availableCount = totalOwned - totalUsed;

                if (availableCount > 0) {
                    hasAvailableCards = true;
                    const cardElement = document.createElement('div');
                    cardElement.classList.add('card-container', 'relative', 'w-32', 'h-auto', 'rounded-lg', 'shadow-md', 'overflow-hidden');
                    cardElement.innerHTML = `
                        <img src="${card.image_uris?.small || 'https://placehold.co/128x178/cccccc/333333?text=Imatge+no+disponible'}"
                             alt="${card.name}" class="w-full h-auto rounded-lg border border-gray-300">
                        <div class="card-count">${availableCount}</div>
                    `;
                    availableCardsList.appendChild(cardElement);
                }
            }

            if (!hasAvailableCards) {
                noAvailableCardsMessage.classList.remove('hidden');
            } else {
                noAvailableCardsMessage.classList.add('hidden');
            }
        };


        // --- Tab 4: Wishlist Logic ---

        // Fetch autocomplete suggestions for Wishlist search
        const fetchWishlistAutocomplete = async (query) => {
            if (query.length < 2) {
                wishlistAutocompleteResultsDiv.classList.add('hidden');
                return;
            }
            try {
                const response = await fetch(`https://api.scryfall.com/cards/autocomplete?q=${encodeURIComponent(query)}`);
                const data = await response.json();
                displayWishlistAutocompleteResults(data.data);
            } catch (error) {
                console.error('Error fetching autocomplete data for wishlist:', error);
                wishlistAutocompleteResultsDiv.classList.add('hidden');
            }
        };

        // Display autocomplete results for Wishlist search
        const displayWishlistAutocompleteResults = (results) => {
            wishlistAutocompleteResultsDiv.innerHTML = '';
            if (results && results.length > 0) {
                results.forEach(cardName => {
                    const div = document.createElement('div');
                    div.classList.add('autocomplete-item');
                    div.textContent = cardName;
                    div.addEventListener('click', () => selectCardForWishlist(cardName));
                    wishlistAutocompleteResultsDiv.appendChild(div);
                });
                wishlistAutocompleteResultsDiv.classList.remove('hidden');
            } else {
                wishlistAutocompleteResultsDiv.classList.add('hidden');
            }
        };

        // Select a card from autocomplete and fetch its full data for Wishlist
        const selectCardForWishlist = async (cardName) => {
            wishlistCardSearchInput.value = cardName;
            wishlistAutocompleteResultsDiv.classList.add('hidden');
            try {
                const response = await fetch(`https://api.scryfall.com/cards/named?exact=${encodeURIComponent(cardName)}`);
                if (!response.ok) {
                    throw new Error(`Carta no trobada: ${cardName}`);
                }
                const cardData = await response.json();
                displaySelectedCardForWishlist(cardData);
            } catch (error) {
                console.error('Error fetching card data for wishlist:', error);
                wishlistSelectedCardDisplay.classList.add('hidden');
                showAlert('No s\'ha pogut trobar la carta o hi ha hagut un error de xarxa. Si us plau, prova-ho de nou.');
            }
        };

        // Display the selected card details for Wishlist
        const displaySelectedCardForWishlist = (cardData) => {
            currentWishlistCard = cardData;
            wishlistCardImage.src = cardData.image_uris?.normal || 'https://placehold.co/223x310/cccccc/333333?text=Imatge+no+disponible';
            wishlistCardImage.alt = cardData.name;
            wishlistCardNameDisplay.textContent = cardData.name;
            wishlistSelectedCardDisplay.classList.remove('hidden');
        };

        // Add card to Wishlist
        addToWishlistBtn.addEventListener('click', async () => {
            if (!firebaseReady) {
                showAlert('L\'aplicaci√≥ encara s\'est√† carregant. Si us plau, espera un moment.');
                return;
            }
            if (!currentWishlistCard) {
                showAlert('Si us plau, selecciona una carta primer per afegir a la llista de desitjos.');
                return;
            }

            // Check if card is already in wishlist
            if (wishlistCards[currentWishlistCard.id]) {
                showAlert(`"${currentWishlistCard.name}" ja √©s a la teva llista de desitjos.`);
                return;
            }

            // Check if card is already in collection (Tab 1)
            if (addedCards[currentWishlistCard.id]) {
                showAlert(`"${currentWishlistCard.name}" ja √©s a la teva col¬∑lecci√≥. No cal afegir-la a la llista de desitjos.`);
                return;
            }

            try {
                await setDoc(doc(wishlistCardsRef, currentWishlistCard.id), {
                    card_data: currentWishlistCard
                });
                // UI updates handled by onSnapshot
                wishlistCardSearchInput.value = '';
                wishlistSelectedCardDisplay.classList.add('hidden');
                currentWishlistCard = null;
            } catch (error) {
                console.error('Error adding card to wishlist:', error);
                showAlert('Error en afegir la carta a la llista de desitjos. Si us plau, prova-ho de nou.');
            }
        });

        // Remove card from Wishlist
        const removeCardFromWishlist = (cardId) => {
            if (!firebaseReady) {
                showAlert('L\'aplicaci√≥ encara s\'est√† carregant. Si us plau, espera un moment.');
                return;
            }
            showConfirmModal(`Est√†s segur que vols eliminar "${wishlistCards[cardId].card_data.name}" de la llista de desitjos?`, async (confirmed) => {
                if (confirmed) {
                    try {
                        await deleteDoc(doc(wishlistCardsRef, cardId));
                        // UI updates handled by onSnapshot
                    } catch (error) {
                        console.error('Error removing card from wishlist:', error);
                        showAlert('Error en eliminar la carta de la llista de desitjos.');
                    }
                }
            });
        };

        // Render the list of wishlist cards
        const renderWishlistCards = () => {
            wishlistCardsList.innerHTML = '';
            const cardIds = Object.keys(wishlistCards);

            if (cardIds.length === 0) {
                noWishlistCardsMessage.classList.remove('hidden');
            } else {
                noWishlistCardsMessage.classList.add('hidden');
                cardIds.forEach(cardId => {
                    const card = wishlistCards[cardId].card_data;
                    const cardElement = document.createElement('div');
                    cardElement.classList.add('card-container', 'relative', 'w-32', 'h-auto', 'rounded-lg', 'shadow-md', 'overflow-hidden');
                    cardElement.innerHTML = `
                        <img src="${card.image_uris?.small || 'https://placehold.co/128x178/cccccc/333333?text=Imatge+no+disponible'}"
                             alt="${card.name}" class="w-full h-auto rounded-lg border border-gray-300">
                        <button data-card-id="${card.id}" class="remove-wishlist-card-btn absolute top-1 right-1 bg-red-500 hover:bg-red-600 text-white text-xs font-bold py-1 px-2 rounded-full transition-colors duration-200">X</button>
                    `;
                    wishlistCardsList.appendChild(cardElement);

                    cardElement.querySelector('.remove-wishlist-card-btn').addEventListener('click', (e) => {
                        const id = e.target.dataset.cardId;
                        removeCardFromWishlist(id);
                    });
                });
            }
        };

        // Event listener for wishlist search input
        wishlistCardSearchInput.addEventListener('input', debounce((e) => {
            fetchWishlistAutocomplete(e.target.value);
        }, 300));


        // --- Tab Switching Logic ---
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.add('hidden'));

                button.classList.add('active');
                const targetTabId = button.id.replace('-btn', '-content');
                document.getElementById(targetTabId).classList.remove('hidden');

                // Re-render lists for the newly active tab
                if (button.id === 'tab1-btn') {
                    renderAddedCardsList(); 
                } else if (button.id === 'tab2-btn') {
                    renderDeckList();
                    populateDeckCollection(deckCollectionSearchInput.value); 
                    updateDeckStatistics(); 
                    if (!selectedDeckId || !allCommanderDecks[selectedDeckId]) {
                        currentDeckEditingArea.classList.add('hidden');
                    }
                } else if (button.id === 'tab3-btn') {
                    renderAvailableCards();
                } else if (button.id === 'tab4-btn') {
                    renderWishlistCards(); 
                }
            });
        });

        // --- Firebase Initialization and Data Loading ---
        const initFirebaseAndLoadData = async () => {
            loadingOverlay.classList.remove('hidden'); // Show loading overlay

            try {
                appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Sign in anonymously or with custom token
                if (typeof __initial_auth_token !== 'undefined') {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }

                userId = auth.currentUser?.uid || crypto.randomUUID();
                userIdDisplay.textContent = userId; // Display the user ID
                console.log("Firebase initialized. User ID:", userId);

                // Initialize Firestore references to a PUBLIC collection
                addedCardsRef = collection(db, `artifacts/${appId}/public/data/addedCards`);
                commanderDecksRef = collection(db, `artifacts/${appId}/public/data/commanderDecks`);
                wishlistCardsRef = collection(db, `artifacts/${appId}/public/data/wishlistCards`);

                // Set up real-time listeners
                onSnapshot(addedCardsRef, (snapshot) => {
                    addedCards = {};
                    snapshot.forEach(doc => {
                        addedCards[doc.id] = doc.data();
                    });
                    console.log("Added Cards updated:", addedCards);
                    renderAddedCardsList();
                    renderAvailableCards();
                    populateDeckCollection();
                    updateDeckStatistics();
                }, (error) => {
                    console.error("Error fetching added cards:", error);
                    showAlert("Error en carregar les cartes de la col¬∑lecci√≥.");
                });

                onSnapshot(commanderDecksRef, (snapshot) => {
                    allCommanderDecks = {};
                    snapshot.forEach(doc => {
                        allCommanderDecks[doc.id] = { id: doc.id, ...doc.data() };
                    });
                    console.log("Commander Decks updated:", allCommanderDecks);
                    renderDeckList();
                    updateDeckCardCount(); // Ensure counts are updated
                    renderAvailableCards();
                    updateDeckStatistics();
                    // If a deck was selected and then deleted by another device, deselect it
                    if (selectedDeckId && !allCommanderDecks[selectedDeckId]) {
                        selectedDeckId = null;
                        currentDeckEditingArea.classList.add('hidden');
                    }
                }, (error) => {
                    console.error("Error fetching commander decks:", error);
                    showAlert("Error en carregar els mazos Commander.");
                });

                onSnapshot(wishlistCardsRef, (snapshot) => {
                    wishlistCards = {};
                    snapshot.forEach(doc => {
                        wishlistCards[doc.id] = doc.data();
                    });
                    console.log("Wishlist Cards updated:", wishlistCards);
                    renderWishlistCards();
                }, (error) => {
                    console.error("Error fetching wishlist cards:", error);
                    showAlert("Error en carregar la llista de desitjos.");
                });

                firebaseReady = true; // Set flag to true after successful initialization

            } catch (error) {
                console.error("Failed to initialize Firebase or load data:", error);
                showAlert("Error cr√≠tic: No s'ha pogut carregar l'aplicaci√≥. Si us plau, recarrega la p√†gina.");
            } finally {
                loadingOverlay.classList.add('hidden'); // Hide loading overlay
            }
        };

        // Initialize Firebase and load data when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', initFirebaseAndLoadData);

        // Initial setup for UI elements that don't depend on Firebase data
        updateColorFilterIcons(); 
    </script>
</body>
</html>
